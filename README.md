# computer-math

## 向量和图形

vector

### 平面向量运算

- 向量和
- 首尾加法
  箭头形式的向量加法，在一个方向上移动了一段距离，在另一个方向上又移动了一段距离，表示移动的整体距离
- 向量平移

#### 向量的分量和长度

1. x分量和y分量
2. 向量长度 sqrt(x^2+y^2)

#### 向量与数相乘

  5v 标量乘法

#### 向量减法

  -1*v 负向量
  减法：向量和负向量的加法

  位移是一个向量（带方向），距离是一个标量。距离不足以说明如何从点A到点B。

### 三角学

极坐标：给定向量长度和角度（从x轴正半轴逆时针旋转的角度），如(5, 37度)。

平常度(x,y)坐标 如(3,4)为笛卡尔坐标。 极坐标和笛卡尔坐标可以互现转换。

#### 重要概念来源

正切： 给定一个角度，该角度上向量的y，x坐标有一个固定比值。

> $\tan(\theta)$ 

正弦：向量的垂直距离与距离的比值

> $\sin(\theta)$ 

余弦：向量的水平距离与距离的比值

> $\cos(\theta)$

弧度：半径为1的圆，圆心角对应的圆边的长度。

> $\pi$ 弧度 = $180^\circ$

弧度和距离都是正数哈。

#### 反三角函数

python里也实现了可以根据三角函数值求出弧度的方法。

> math.asin （不是唯一解）
> 
> math.acos （不是唯一解）
> 
> math.atan2 接受笛卡尔坐标（按相反的顺序），返回对应的弧度

#### 向量集合的变换

> 笛卡尔坐标适合向量移动，极坐标适合向量旋转

在极坐标体系中，角度的相加会使向量逆时针旋转，角度的相减会使向量顺时针旋转。

重要操作

- 平移

- 缩放

- 旋转

> 通常以不同的顺序应用旋转和平移，结果不同。

对一个向量集合都应用相同的变换，可以达到变换图形的效果，是非常重要的思想。

## 三维向量

### 三维世界中的向量表示

(x,y,z)
用箭头和点在三维空间中充当向量的心智模型。

### 三维向量运算

#### 相加

跟二维一样，把所有向量的x坐标、y坐标、z坐标分别相加。

> zip和sum函数的运用

#### 三维向量乘以标量

v = (1,2,3)
2*v = (2,4,6)

#### 三维向量减法

v-w 从w到v的位移向量

#### 三维空间中长度和距离

sqrt(sum([coord ** 2 for coord in v]))

#### 计算角度和方向

三维向量可以看作箭头，或沿着一定方向发生的一定长度的位移。

在二维空间中，两个数足以指定任何而为乡里那个（一个长度和一个角度-极坐标，指明方向）；
但在三维空间中，一个角度不足以指明方向，但两个可以。 

球坐标 (r, $\phi$ , $\theta$)

#### 点积

向量乘法的一种，取两个向量相乘，返回一个标量。

二维和三维空间中，这些几何性质都适用：
（双向点）

- 两个向量夹角小于90度，点积为正
- 两个向量相互垂直，点积为0
- 两个向量夹角大于90度，点积为负，且越长积越小，即负值越大

##### 计算点积

将对应点坐标分别相乘，然后求和。

将任意一个向量scale，点积也会翻倍。

- 向量越长，点积绝对值越大
- 两个长度为a和b的向量点积范围为： -|a*b| ~ |a*b|

##### 用点积计算角度

还有另一个计算点积的公式

> u $\cdot$ v = |u|$\cdot$|v|$\cdot$ $\cos$ ($\theta$)

我们通过向量长度和点积，可以反推出向量的夹角。

#### 向量积

向量乘法的另一种，取两个向量相乘，返回另一个向量。

- 向量积可以判定朝向

- 向量积垂直于2个输入向量，符合右手规则
  
  > u、v 和 u $\times$ v 构成右手系，食指指向u，三指弯向v，拇指指向向量积

- 向量积在二维空间无意义

##### 向量积的长度

两个输入向量u和v，向量积的**长度**代表u和v构成的平行四边形的**面积**。

> u和v垂直时候面积最大，u和v同方向则不存在唯一垂直方向，向量积长度为0（最终的向量长度也为0）

> u * v * $\sin$($\theta$)

##### 计算三维向量的向量积

u和v两个向量

> u $\times$ v =  (uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx)



## 变换向量和图形

向量变换：

- 平移

- 缩放

- 旋转

- 线性变换

向量随着时间变化。

> 使用更先进的图形绘制库OpenGL - PyOpenGL和pygame

```
pygame
PyOpenGL
```

### 变换三维对象

```python
def transform(v):
    old_x, old_y, old_z = v
    # 此处做一些操作
    return (new_x, new_y, new_z)
```



<mark>运行源代码中Chapter 04下的draw_teapot.py</mark>

三维向量变换的唯一要求是，接收一个单独的三维向量作为输入，并返回一个新的三维向量作为输出。



#### 变换

- 缩放 scale2.py

- 平移 shiftt_1.py



#### 组合向量变换

画图

可以既缩放又移动，把标量乘法、平移等操作叠加。

> 向量变换以向量为输入输出，可以通过函数组合来组合任意的向量。



> 柯里化(currying) 接收多个输入的函数重构为返回另一个函数的函数。

按照系数-1缩放，是得到镜像，慎用。

#### 绕轴旋转

> 绕哪个轴旋转，哪个轴的坐标就不变。 可以应用这个，对三维向量的另2个坐标应用二维旋转函数。



- 转换成极坐标

- 逆时针旋转角度

- 转化为笛卡尔坐标



组合函数

```python
compose(f,g,h)(x) = f(g(h(x)))
```





### 线性变换

#### 理解

对于任意输入向量u和v，

> T(u) + T(v) = T(u+v)

对于任意标量s和向量v，有：

> T(sv) = sT(v)

T是线性变换的数学表示。

线性变换是一种well-behaved的向量变换，保持了向量的

- 向量和

- 标量乘积

- 线性组合



**非零向量的平移不是线性变换！**



**线性组合：**

向量u和v，3u-2v是u和v的线性组合。



向量u和v之间线段的中点，也是0.5u + 0.5v的尾巴节点。即T(1/2u+1/2v)  = 1/2T(u) + 1/2T(v)

0.25u + 0.75v也在**u**和**v**之间的线段上。在从u到v的路径上的75%处。

**两个向量u和v之间线段上的每个点都是形如 su + (1-s)v的"加权平均值"，其中s介于0和1之间。**

线性变换T将u和v的加权平均值转化为T(u)和T(v)的加权平均值。

> T(s$\cdot$u + (1-s)$\cdot$v) = s$\cdot$T(u) +(1-s)$\cdot$T(v)



**可以预见，线性变换可以保持三维模型的结构。**

**两个线性变换的组合也是线性的。**



#### 计算线性变换

##### 标准基

> (1,0,0) (0,1,0),(0,0,1)这三个向量。分别表示为e1,e2,e3

(3,4,5) = 3e1+4e2+5e3

当然二维向量也适用，(1,0) (0,1)



##### 示例

2d

v=(3,2)

>  T(v) = T(3e1+2e2) = 3T(e1) + 2T(e2)



3d

A是一个线性变换，A(e1)=(1,1,1), A(e2)=(1,0,-1), A(e3)=(0,1,1)

如果v=(-1,2,2)，那么A(v)是什么？

>  A(v) = A(-e1+2e2+2e3)=-A(e1) + 2A(e2) + 2A(e3) = (1, 1, -1)



**在任意维中，线性变换的行为由一个向量列表或数组阵列来规定 - 矩阵**